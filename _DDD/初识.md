## 1.1 领域驱动设计概览

### 什么是领域驱动设计

- 将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承和多态等设计要素。降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题
- 领域驱动设计不是架构方法，也并非设计模式。准确地说，它其实是“一种思维方式，也是一组优先任务，它旨在加速那些必须处理复杂领域的软件项目的开发
- 领域驱动设计强调领域模型的重要性，并通过模型驱动设计来保障领域模型与程序设计的一致。从业务需求中提炼出统一语言（Ubiquitous Language），再基于统一语言建立领域模型。领域模型指导设计与编码。通过重构来发现隐式概念，并运用设计模式改进设计与开发质量

### 领域驱动设计的特点

- 领域驱动设计贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，甚至最终的编码实现，乃至对编码的测试与重构

### 领域驱动层级划分

> 领域驱动可能会面临高复杂度的挑战。在为问题域寻求解决方案时，需要从宏观层次划分不同业务关注点的子领域，然后再深入到子领域中从微观层次对领域进行建模。
>
> 宏观层次是战略的层面，微观层次是战术的层面

#### 战略设计

- **问题域方面**：针对问题域，引入**限界上下文（Bounded Context）**和**上下文映射（Context Map）**对问题域进行合理的分解，识别出**核心领域（Core Domain）**与**子领域（SubDomain）**，并确定领域的边界以及它们之间的关系，维持模型的完整性
- **架构方面**：通过**分层架构**来隔离关注点，尤其是将领域实现独立出来，能够更利于领域模型的单一性与稳定性；引入**六边形架构**可以清晰地表达领域与技术基础设施的边界；CQRS 模式则分离了查询场景和命令场景，针对不同场景选择使用同步或异步操作，来提高架构的低延迟性与高并发能力

#### 战术设计

在战术层面，它主要应对的是领域的复杂性。领域驱动设计用以表示模型的主要要素包括：

- 值对象（Value Object）
- 实体（Entity）
- 领域服务（Domain Service）
- 领域事件（Domain Event）
- 资源库（Repository）
- 工厂（Factory）
- 聚合（Aggregate）
- 应用服务（Application Service）

战术设计诸要素之间的关系：

![img](../images/999999/41040a90-7854-11e8-9ada-255ab1257678)

- 领域驱动设计围绕着领域模型进行设计，通过**分层架构（Layered Architecture）**将领域独立出来。表示领域模型的对象包括：**实体**、**值对象**和**领域服务**，**领域逻辑都应该封装在这些对象中**。在领域驱动设计的演进中，又引入了**领域事件**来丰富领域模型。
- **聚合**是一种边界，它可以封装一到多个**实体**与**值对象**，并维持该边界范围之内的业务完整性。在聚合中，至少包含一个实体，且只有实体才能作为**聚合根（Aggregate Root）**。聚合代表的是边界概念，而非领域概念。
- **工厂**和**资源库**都是对领域对象生命周期的管理。前者负责领域对象的创建，往往用于封装复杂或者可能变化的创建逻辑；后者则负责从存放资源的位置（数据库、内存或者其他 Web 资源）获取、添加、删除或者修改领域对象。领域模型中的资源库不应该暴露访问领域对象的技术实现细节

## 1.2 深入分析软件的复杂度

### 复杂度成因

- 没有对行为的重用，也没有对业务问题的抽象，每当操作用到业务规则时，都要重复这些业务规则
- 快速的原型建立和迭代很快会达到其极限，因为抽象的缺乏限制了重构的选择
- 复杂的功能很快会让你无所适从，所以程序的扩展只能是增加简单的应用模块，没有很好的办法来实现更丰富的功能

### 什么是复杂

- 由大量相互作用的部分组成的系统，与整个系统比起来，这些组成部分相对简单，没有中央控制，组成部分之间也没有全局性的通讯，并且组成部分的相互作用导致了复杂行为。软件设计中组成部分所谓的“设计单元”，基于粒度的不同可以是函数、对象、模块、组件和服务。这些设计单元相对简单，然而彼此之间的相互作用却导致了软件系统的复杂行为。

> 要理解软件复杂度的成因，就应该结合**理解力**与**预测能力**这两个因素来帮助我们思考。

### 理解力

#### 一、影响理解力要素：**规模**

- 软件的需求决定了系统的规模。当需求呈现线性增长的趋势时，软件规模也会以近似的速度增长。而且需求不可能做到完全独立，会大量出现相互影响相互依赖的关系

#### 二、影响理解力要素：**结构**

- 系统的质量属性决定着结构的复杂性。为了提高系统的质量就要增加结构的复杂程度，比如：引入cache、拆分微服务架构等

### 预测能力

- 变化可能来自业务需求，也可能来自质量属性或者依赖的第三方系统和工具。变化影响着预测能力

## 1.3 控制软件复杂度的原则

### 分而治之、控制规模

- 要求一个程序只做一件事情，符合“单一职责原则”，在应对新需求时，不会直接去修改一个复杂的旧系统，而是通过添加新特性，然后对这些特性进行组合
- 每个程序的输入和输出都是统一的，因而形成一个统一接口（Uniform Interface），以支持程序之间的自由组合（Composability）。利用统一接口，既能够解耦每个程序，又能够组合这些程序，还提高了这些小程序的重用性，这种“统一接口”，其实就是架构一致性的体现

### 保持结构的清晰与一致

> Robert Martin 分析了以下系统架构风格与模式。认为这些方法的共同特征都遵循了“关注点分离”架构原则，由此提出了整洁架构的思想。
>
> -  Alistair Cockburn 提出的**六边形架构**（Hexagonal Architecture）
> - Jeffrey Palermo 提出的**洋葱架构**（Onion Architecture)
> - James Coplien 与 Trygve Reenskaug 提出的**DCI 架构**
> - Ivar Jacobson 提出的**BCE 设计方法**

#### 整洁型架构

![img](../images/999999/a2ff02f0-790c-11e8-97d2-5b3665c292ea)

- 整洁架构提出了一个可测试的模型，无需依赖于任何基础设施就可以对它进行测试，只需通过边界对象发送和接收对应的数据结构即可
- 遵循**稳定依赖原则**，不对变化或易于变化的事物形成依赖。整洁架构模型让外部易变的部分依赖于更加稳定的领域模型，从而保证了核心的领域模型不会受到外部的影响
- 其目的在于识别整个架构不同视角以及不同抽象层次的关注点，并为这些关注点划分不同层次的边界，从而使得整个架构变得更为清晰，以减少不必要的耦合。

### 拥抱变化

在架构设计层面，我们还可以分析哪些架构质量属性与变化有关，这些质量属性包括：

- **可进化性（Evolvability）**：划分设计单元的边界，以确定每个设计单元应该履行的职责以及需要与其他设计单元协作的接口。这些设计单元具有不同的设计粒度，包括函数、对象、模块、组件及服务。由于设计单元间弱性依赖，就可以非常容易地替换单元内部的实现细节，保证它们的可进化性
- **可扩展性（Extensibility）**：学会识别软件系统中的变化点（热点），常见的变化点包括业务规则、算法策略、外部服务、硬件支持、命令请求、协议标准、数据格式、业务流程、系统配置、界面表现等。处理这些变化点的核心就是“**封装**”，通过隐藏细节、引入间接等方式来隔离变化、降低耦合。
- **可定制性（Customizability）**：代表可以提供特别的功能与服务。引入元数据（Metadata）、插件模式是满足可定制性的常见做法

## 1.4 领域驱动设计对软件复杂度的应对

>Eric Evans 认为“很多应用程序最主要的复杂性并不在技术上，而是来自领域本身、用户的活动或业务”。因而，领域驱动设计关注的焦点在于**领域和领域逻辑**，因为软件系统的本质其实是给客户（用户）提供具有业务价值的领域功能。

### 需求引起的软件复杂度

> 需求分为业务需求与质量属性需求，因而需求引起的复杂度可以分为两个方面：**技术复杂度**与**业务复杂度**。

#### **技术复杂度来自需求的质量属性**

- 安全、高性能、高并发、高可用性等需求。以及彼此间的相互影响和相互排斥

#### **业务复杂度对应了客户的业务需求**

- 这种复杂度往往会随着需求规模的增大而增加
- 不仅是功能数量的增加，还会因为功能互相之间的依赖与影响使得这种复杂度产生叠加，进而影响到整个系统的质量属性

#### 两种复杂度的混合

### 领域驱动设计的应对措施

> - 问题域过于庞大而复杂，使得从问题域中寻求解决方案的挑战增加，该问题与软件系统的**规模**有关
> - 开发人员将业务逻辑的复杂度与技术实现的复杂度混淆在一起，该问题与软件系统的**结构**有关
> - 随着需求的增长和变化，无法控制业务复杂度和技术复杂度，该问题与软件系统的**变化**有关

#### 隔离业务复杂度与技术复杂度

- 确定业务逻辑与技术实现的边界，从而隔离各自的复杂度
- 领域驱动设计通过**分层架构**与**六边形架构**来确保业务逻辑与技术实现的隔离

##### **分层架构的关注点分离**

![img](../images/999999/bcda5e80-7912-11e8-ae3a-c9b56e7fe402)

> 蓝色区域的内容与业务逻辑有关，灰色区域的内容与技术实现有关
>
> 应用层确定了业务逻辑与技术实现的边界

- 分层架构遵循了“关注点分离”原则
- 属于业务逻辑的关注点放到领域层（Domain Layer）
- 而将支撑业务逻辑的技术实现放到基础设施层（Infrastructure Layer）
- 应用层扮演了双重角色。一方面它作为业务逻辑的外观（Facade），暴露了能够体现业务用例的应用服务接口；另一方面它又是业务逻辑与技术实现的粘合剂，实现二者之间的协作

##### **六边形架构的内外分离**

![img](http://images.gitbook.cn/cfe6ecf0-7912-11e8-9353-3d7605954bd0)

> 由 Cockburn 提出的六边形架构则以“内外分离”的方式，更加清晰地勾勒出了业务逻辑与技术实现的边界，且将业务逻辑放在了架构的核心位置。这种架构模式改变了我们观察系统架构的视角

- 体现业务逻辑的应用层与领域层处于六边形架构的内核，并通过内部的六边形边界与基础设施的模块隔离开
- 只要恪守架构上的六边形边界，则不会让技术实现的复杂度污染到业务逻辑，保证了领域的整洁
- 边界还隔离了变化产生的影响

### 限界上下文

> 缓存放在系统的应用层，从层次的职责来看，这样的设计是合理的，但它却使得系统的应用层变得更加臃肿，职责也变得不够单一。这是分层架构与六边形架构的局限所在，因为这两种架构模式仅仅体现了软件系统的逻辑划分。可以通过垂直拆分系统来解决上面这个问题，具体做法是将缓存拆到另一个独立的子系统中去。这种拆分的概念在领域驱动设计中，被称之为限界上下文（Bounded Context）
>
> 针对庞大而复杂的问题域，限界上下文采用了“分而治之”的思想对问题域进行了分解，有效地控制了问题域的规模，进而控制了整个系统的规模。

### 领域模型对领域知识的抽象

- 领域模型是对业务需求的一种**抽象**，其表达了领域概念、领域规则以及领域概念之间的关系。模型是封装，实现了对业务细节的隐藏；模型是抽象，提取了领域知识的共同特征，保留了面对变化时能够良好扩展的可能性







